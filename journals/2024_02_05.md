- 10:01 In #15418/Lecture
- #15418/Problem-Constrained scaling - have a problem. Run it on different processor counts and measure different speedup counts
- #15418/Time-constrained scaling - completing more work in a fixed amount of time.
	- example: Real-time 3D graphics: more compute power allows more rendering of complex scenes
	- size metrics: number of polygons, texels sampled, shader length, etc.
	- Computational finance: most sophisticated model possible to trade
- #15418/Memory-constrained scaling - scale to largest problem without overflowing "main memory"
	- doesn't hold work or execution time constant
	- Example: Pixar rendering images (a lot of memory to load up)
	- See best speedup with MC scaling, TC scaling, and worst with PC scaling
- #15418/Problem-Scaling thoughts
	- In practice, problem size is combination of parameters, For Ocean example: (n, $\epsilon$, $$\Delta$$ t, T)
- #15418/Scaling TL;DR
	- Performance improvement due to aprallelism
	- speedup metrics have different forms for differetn models
	- Need to keep in mind different scaling properties of the problem and the machine.
	- Requires application knowledge to do proper speedup
- #15418/Testing How to test parallel machine idea?
	- Evaluate architectural idea: simulation with chip simulators
	- Expensive to simulate a parallel machine in full detail, assume some ideas (e.g. optimal adder)
	- Simulations are often slower than actual machine configurations
- #15418/Simulation/Execution-driven
	- Executes simulated program in software
	- Usually inversely proportional to level of simulated detail #Maybe look back at 15418 slides to see at the detail again
- #15418/Simulation/Trace-driven
	- Instrument real code running on real machine to record a trace of all memory accesses
		- can also generate trace through #15418/Simulation/Execution-driven simulator
	- Play back trace on simulator
- #15418/Debugging
	- May want to log behavior of code when debugging, can sometimes get very big or slow down code
	- May want to debug/test/tune code on small problem size on small machine before running long simulation.
	- Scaling down assignment 2
		- Problem size = (w, h, num_circles)
		- Make Image smaller (circle cnt is the same, but smaller w, h)
		- Render crop of full-size Image --> smaller circle_cnt
	- Try the simplest parallel solution first,
		- measure performance to see where you stand
		- Find bottlenecks
	- Establish high watermarks --> to find bottlenecks:
		- Add math
		- Remove almost all math but load same data
		- Change all array accesses to A[0]
		- Remove all atomic operations or locks
		- Use profilers/performance monitoring tools to measure performance using tools
- Performance and stuff. c++, low level latency projects. Distributed architecture. Many applications that aren't centrally controlled. Exchance data and reason about integrity of streams of data. Coherent picture.
- asynchronous behavior to work correctly
- Message Bus [[Dennis Gurzhii]]
	- Manager & Mentor. Work closely with manager on deliverables and pointers on basic stuff about the product.
	- Evaluate my performance at the end. Mentor can give me more help on the low level details and career advice
	- Internship to FT --> can be given by mentors, mentor will be important contact points
		- SCRUM? 2 week sprints. Daily meetings to be apart of.
		- Zoom n slack interactions happen a lot. Distributed communications
	- Projects:
		- Allow a lot of configuration in the system. Improve optimization, scale, while also allowing features and recovery from disaster scenarios
		- Reliability: Fault tolerant in many scenarios is very hard. Safety guards and failure analysis.
		- HOT: replace old infra with Message Bus stuff matched
- Platform Integration [[Matthew Fioravante]]
	- in between different tech teams at CitSec
	- need a platform to allow for integration easily
	- trying to push core message bus across all teechnologies
	- publish trades to all applications. Many low level engineering, performance, traders and getting their needs to deliver solutions
	- Message Bus uses multicasts on UDP. Message Bus has reliable multicast. Detects for Gap and broker will get the message again. Discovery service gets datasets A, B, C for us in an abstraction.
	- Want to replace old system
	- Platform drives platform, and keeps project on track
		- TPM project example: PnL used to be used.  Monitor capital usaged. Queueing and KDB framework used
		- Drive teams to completion.
		- SWAT team help and help manage different designs. Like consultants for tech.
	- KPD, priorites change very quickly so no known projects
	- Cleaning up code, Visualization and UI and introspection, and performance analysis.
	- Getting their skillset interests, etc. etc..  Matching people with their teams on impact. Need high impact
	- Technical excellence required. Flexibility in actions and new ways of doing stuff.
		- Being able to talk to team members for QR and traders. Interest in Quant finance.
	- Fail-Over system for TPM.
	- Data Stream - Wide application consuming the data based off of data sets.
		- QR run backtest over data stream and measure performance
		- Capture and archive datastreams and replay historically
		- backtesting: exact code runs
			- callbacks for trading: trade event occurred.
		- Want to run exact same code on the network. Running a simulation over the data on historical instead of live
	- Building events:
	- Kernel Context switch: libraries for configuration. sometimes misconfiguration causes performance.
	- A lot of things to thinking about the problem and systematically looking into what's wrong.
- #Writing
	- Requirements for Memo
		- Get job Ad
		  logseq.order-list-type:: number
		- Put revision section with the analysis section
		  logseq.order-list-type:: number
- 18:26 In 15451 OH. I 've been here for about an hour now. Looking at 15418 stuff now though to spend the time. Done thinking
- 19:01 Barely submitted my coding homework in time. I'm really like that rn
- #Security ASLR, DEP, stack canaries are foundational cybersecurity protections:
	- How to avoid ASLR
		- #Brute-Force shell code attack - Shell code and have a big NOP slide
		- #Ret2Text - text section has executable program code
			- note randomized by ASLR (usually) except PIE
			- Can hijack control flow to unintended program function
		- #function-pointer-subterfuge - Overwrite a function pointer to point to program function (like #Ret2Text )
			- usually with standard buffer overflow methods
- #Security/ROP - Forge shell code out of existing app logic gadgets
	- Requirements: vulnerability + gadgets + some unrandomized code
	- ret is an indirect jump to stuff on stack.
	- Instruction is useful if it ends in a ret instruction
- #Security/R2R - valuable potential shellcode pointer on a stack.
	- looks like a NOP slide but with Ret instruction
- #Security - takeaways
	- Control flow hijack
	- Control + computation
	- Buffer overflows overwrite return address
	- Format string vulnerabilities
		- read/write arbitrary memory
	- Defenses:
		- #Canary, #DEP, #ASLR
		- Beatable with clever tricks like returning to
-
	-
	-