- 15:09 Need to reevaluate my design before I dive back into the code again
- Looking to read over 15451 and 15445 readings that I missed last week.
	- Hoping to catch and potentially do some of 15451 problems (Not a requirement though)
- #15451 Average cost == expected value of function over uniform distribution.
	- *Upper bound of U*: for a problem of length n, $\exists$ an algorithm A s.t. $\forall$ input x of length n costs at most $U$
	- *Lower bound of $L$*: For any algorithm A, there exists an input x of length n which A costs at least $L$
	- A function is an upper bound/lower bound if $f(n)$ is an upper bound/lower bound $\forall$ n
	- One way to do lower bound arguments is through the *adversary technique*, where if adversary knows the algorithm, make an input that causes worst case behavior
	- *Decision trees* - Binary tree where node represents a decision made (e.g. comparison is true or false) $\implies$ height of tree is worst case behavior
		- Proof for select-max under decision trees: Root node has n possibilities for max element. At the children, an element will lose a comparison. The set of possibilities for root decreases by 1. This continues until the leaves when there is only 1 possible element for max. It will take $n-1$ comparison to reach a leaf
- #15451/Theorem Any deterministic comparison absed sorting algorithm must perform at least $lg(n!)$ comparisons to sort n distinct elements in the worst case.
	- #15451/Proof Note givens: Algorithm A is deterministic. Thus, first comparison will always be between the same indices. Results of previous comparisons always decides next comparison to make.
		- Write comparisons as sequence of bools. E.g. (True, False, True)
		- Since values don't matter, think of input as a sequence of ranks
			- (3, 1, 2) would be 1st element is 3rd big, 2nd is most, 3rd is 2nd
		- Map possible comparison sequences to an output ordering.
			- For length $l$, there are $2^l$ sequences
		- First, get the number of output orderings. n ranks means $n!$ possible inputs due to permutations.
		- Then we need $2^l\geq n!\implies l\geq lg n!$
		- Generalization: If Algorithm needs to produce $M$ different outputs, comparison model has worst case lower bound of $lg M$
	- Proof is "Information theoretic" - requires certain amount of information about the problem before we can actually solve it.
	- $lg n\leq nlgn$ refer to [Lecture 2](https://www.cs.cmu.edu/~15451-s24/lectures/lecture02-lower-bounds.pdf) for more detail also listed here --> ((65ad8ab5-63c7-4f50-a682-bfa9debae055))
- #15451/hw1
	- Problem 1 idea is to get all subarrays $A[i*k:i(i+1)*k]$ and get the max index.
		- Create a new set with each of the max indices obtained prior and run the set operation again.
		- The result is the answer.
- #15455/P0 Implement an Observed Remote Set (OR-Set): [Conflict-free replicated free](https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type)
- #15451 Exchange Model - Swapping elements has cost 1.
	- To sort an array, it will take a cost of n - 1. ((65ad93e0-5243-42b3-b70c-e9ca96b6d55e))
	-
-